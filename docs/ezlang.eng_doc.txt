ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡· ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡· EZLanguage Project |
ğŸ‡§ğŸ‡· ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡· By: Gabriel Luiz |
ğŸ‡§ğŸ‡·
                 Introduction:
EZL is a simple programming language compiler similar to C language but with less functionality,
yet EZL preserves the complex expressions and branching instructions of the C language.
In EZL, we use Flex (a Lex-like compiler generation tool) to generate the lexer parser and
used Bison (a Yacc-like compiler generation tool) to generate the parser.
Although EZL is a mini version of the C language, it provides powerful error handling techniques with
Significant error message reports for various syntax and semantic error scenarios.
Overview
In this section, we will give a brief description and examples for the syntax and semantics
permitted by the EZL. As we said, it is almost identical to the C language, but with fewer features.

             Data types:

In the EZL, we support basic data types, but unfortunately, we don't support arrays or pointers.
Supported types:
â€¢ void: Only valid as a function return type to indicate that there is no value to return
â€¢ int: It is an integer numeric value data type.
â€¢ char: It is a character value data type.
â€¢ float: It is a real numeric value data type.
â€¢ char: It is a character value data type.
â€¢ bool: It is a boolean value data type that accepts true or false.


             Variable/Constant Declarations:

In EZL, we support declaring scoped variables and constants. Each variable or constant has its own
scope and multiple variables/constants can be declared with the same identifier only if they are in
different scopes. As in the C language, constants must be initialized when they are declared.
for example:

ğŸ‡§ğŸ‡·
int x;
const float PI = 3.14;
char c = 'c';
bool flag = true;
int a = 0, b, MAX = 100;
ğŸ‡§ğŸ‡·

          'If-Else Control Statements:

We support the if-else control statement in almost exactly the same way as in the C language.
evaluates to a non-zero value, so the if-body will be executed. Otherwise, the other body will be
executed if it exists. If-body and else-body can be one statement or can be multiple statements
closed by a block.
for example:

ğŸ‡§ğŸ‡·
if (x) {
if (y > 0)
/* if body */;
else if (z & 1)
/* else-if-body */;
else
/* else-body */;
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·

             exchange declarations

Like the if statement, we support the switch statement in almost the same way as in the C language.
switch-expression must be an integer value and case-expression must be a constant integer value.
Also, multiple case expressions that evaluate to the same value are not allowed. Like C, the code of
corresponding case will be executed and execution will continue in the code below other cases until a
the break statement was encountered.

ğŸ‡§ğŸ‡·

switch(state) {
case 1:
case 2:
/* do something */
case RUNNING: // RUNNING must be set to constant
/* do something */
break;
default:
/* default */
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·

             For/While/Do-While Loops
EZL supports loops in almost exactly the same way as the C language. We support for loops, while loops,
and do-while loops. Break-statements and continue-statements are supported within the scope of a
loop and work as in the C language, interrupt or continue the execution of the innermost loop.

examples:
ğŸ‡§ğŸ‡·
for (initializationStatement; testExpression; updateStatement)
ğŸ‡§ğŸ‡·
     // statements inside the body of loop
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·
while (condition) {
   // code block to be executed
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·
int main(void)
ğŸ‡§ğŸ‡·
   float grade1=0, grade2=0,average=0;
   int resp;
  
   of
   ğŸ‡§ğŸ‡·
     printf("Enter the first grade: ");
     scanf("%f",&note1);
     printf("Enter the second note: ");
     scanf("%f",&note2);
    
     average = (grade1 + grade2)/2;
     printf("Student average = %f\n",average);
    
     printf("Type 1 to continue or 2 to exit\n");
     scanf("%d", &resp);
  
   }while(resp==1);
  
   return 0;
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·

                 Functions

EZL supports functions but with limited functionalities than C language.
default parameters. We do not support protection

function typing or function overloading.
Callback statements are allowed within the scope of a function. And functions can only be defined in the
Global scope.

example:
ğŸ‡§ğŸ‡·
int fibonacci(int number) {
return fibonacci(number - 1) + fibonacci(number - 2);
ğŸ‡§ğŸ‡·
ğŸ‡§ğŸ‡·

                 Expressions
In EZL, we support complex expressions similar to those of the C language.
set of operators supported by the C language with the same precedence and associativity.

example:
ğŸ‡§ğŸ‡·

(((++x) = y++) = (5 * 200 - MAX) ^ (1 << id)) = (z = 3);
ğŸ‡§ğŸ‡·

                 Comments

EZL supports the same comment styles as the C language. Comments can be:

â€¢ Line comment
// This is a one-line comment

â€¢ Block comment (multi-line comment)
ğŸ‡§ğŸ‡·
* This is a block comment
* which may cover
* multiple lines
ğŸ‡§ğŸ‡·

             [Errors detected]:
In this section, I'll list some of the syntax and semantic errors that the EZL can detect.

syntax errors
Scope related errors:

1. Blocks of code or instructions (other than variables, constants and function declaration/definition)
at the global level.
2. Continue statement outside for, while, or do-while scopes.
3. Break-statement outside of for, while, do-while, or switch scopes.
4. Return statement outside the scope of the function.
5. Case and default outside the scope of the switch.

Other syntax errors:
1. Variable or constant declared with type void.
2. Constant statement without initialization.
3. Any other invalid syntax

semantic errors

Identifier/expression related errors:
1. Redeclaration of the identifier in the same scope.
2. Undeclared identifier access.
3. Constant attribution after declaration.
4. Invalid operand types. (that is, operands of type void or pointer to function).
5. Floating operand for modulus operator.
6. Floating operand for bitwise operators.
7. Use of uninitialized variable.
8. Increment and decrement operators with r-value operand.

Switch statement-related errors
1. Switch and case statements with non-integer expression.
2. Case statement with non-constant expression.
3. Multiple default labels in switch scope.
4. Multiple labels match the same constant expression in the scope of the switch.
5. Initialization of cross variables in switch statement.

Function related errors:
1. Value returned in the void function.
2. Void returned in the typed value function.
3. Calling a variable or constant as a function.
4. Function call with more/less arguments than its parameters.
5. Function call with invalid argument type (ie argument of type void or function pointer).
6. Function parameter with default value.

                 [TOKENS]:
Using Flex to write the regular expression of tokens allowed by EZLang.
The following table contains a list of these regular expressions.

             Regex token description:
         [0-9]+ Positive integer
         (([0-9]*\.[0-9]+)|([0-9]+\.[0-9]*)) Positive floating number
         ([eE][-+]?{INTEGER}) Exponentiation
         ({INTEGER}{EXP}|{FLOAT}{EXP}?) Positive real number
         [_a-zA-Z]([_a-zA-Z]|[0-9])* Identifier
         (\'.\') Character value
         Boolean values "true", "false"
         "void", "bool", "char", "int", "float" Data Types
         "if", "else", "switch", "case", "default",
         "to", "do", "while", "break", "continue",
         "return", "const"

         [Reserved keywords]:
                 ğŸ‡§ğŸ‡·
             ğŸ‡§ğŸ‡·
             ğŸ‡§ğŸ‡·
             ğŸ‡§ğŸ‡·
             ğŸ‡§ğŸ‡·
             ğŸ‡§ğŸ‡·

         [Operators similar to C language]:

     ğŸ‡§ğŸ‡· Other allowed tokens
     "//"(.)* Line comment
     [ \t\r\n]+ Whitespace

        [Production rules]:

Using Bison to write the production rules that define the EZLang syntax.
Using Bison's precedence and associativity features to resolve the following ambiguity:
1. The precedence and associativity of mathematical operators.
2. The dangling else problem.
The following table contains a list of the used production rules.
Using the following naming convention for the symbols below:
â€¢ Capitalized words for terminal symbols
â€¢ Lowercase words for non-terminal symbols

         [Syntax Production Rule]:
             Main rules:
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â†’ ğœ€
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ â†’ '{' '}'
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ â†’ '{' ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ '}'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğµğ‘…ğ¸ğ´ğ¾ ';' ğŸ‡§ğŸ‡· ğ¶ğ‘‚ğ‘ğ‘‡ğ¼ğ‘ğ‘ˆğ¸ ';' ğŸ‡§ğŸ‡· ğŸ‡§ğŸ‡·
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ ğ‘¤ğ‘–ğ‘¡ğ‘â„_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘‘ğ‘œ_ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› | ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›_ğ‘ ğ‘¡ğ‘šğ‘¡ ';'
             Declaration of Variables/Constants
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘…
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ¶ğ‘‚ğ‘ğ‘†ğ‘‡ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘…
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ‘ ğ‘–
ğ‘£_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ¶ğ‘‚ğ‘ğ‘†ğ‘‡ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… ': =' ğ‘’âˆ´
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘£_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ ': =' ğ‘’âˆ´
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ ': =' ğ‘’âˆ´
             Expression Rules
ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 | ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 | ğ‘’ğ‘¥ğ‘ğ‘Ÿ3
ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ‘‚ğ‘ƒğ‘…ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ 
ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 â†’ ğ‘‚ğ‘ƒğ‘…ğ‘¢ğ‘›ğ‘ğ‘Ÿğ‘¦ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
Note: ğ‘‚ğ‘ƒğ‘…ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦ is being substituted by all binary operators and ğ‘‚ğ‘ƒğ‘…ğ‘¢ğ‘›ğ‘ğ‘Ÿğ‘¦ is being substituted by all
unary operators except increment and decrement operators
ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 â†’ ğ¼ğ‘ğ¶ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ·ğ¸ğ¶ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ¼ğ‘ğ¶ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ·ğ¸ğ¶
ğ‘’ğ‘¥ğ‘ğ‘Ÿ3 â†’ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')'
ğ‘’ğ‘¥ğ‘ğ‘Ÿ3 â†’ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ | ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… | ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘ğ‘ğ‘™ğ‘™
             Branch Rules
ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¼ğ¹ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¼ğ¹ '(' ğ‘’Ì‚ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘¦ ğ¸ğ¿ğ‘†ğ¸ ğ‘ğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘ ğ‘¤ğ‘–ğ‘¡ğ‘â„_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘†ğ‘Šğ¼ğ‘‡ğ¶ğ» '(' ğ‘’Ì‚ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¶ğ´ğ‘†ğ¸ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ':' ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ·ğ¸ğ¹ğ´ğ‘ˆğ¿ğ‘‡ ':' ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘Šğ»ğ¼ğ¿ğ‘› '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')'
ğ‘‘ğ‘œ_ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ·ğ‘‚ ğ‘ğ‘Ÿ_ ğ‘Šğ»ğ¼ğ¿ğ¸ ğ‘Šğ»ğ¼ğ¿ğ¸ '(' ğ‘’Ì‚ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')'
ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¹ğ‘‚ğ‘… '(' ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ ';' ğ‘“ğ‘œğ‘Ÿ_ğ‘’âˆ´ ''; 'ğ‘“ğ‘œğ‘Ÿ_ğ‘’âˆ´ğ‘’') 'ğ‘ğ‘Ÿ_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğœ€ | ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘“ğ‘œğ‘Ÿ_ğ‘’ğ‘¥ğ‘ğ‘Ÿ â†’ ğœ€ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›

             Role Rules
ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… '(' ğ‘_ğ‘™ğ‘–ğ‘ ğ‘¡ ')' ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğœ€ | ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™
ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™
ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘ğ‘ğ‘™ğ‘™ â†’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘…'
ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğœ€ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘…ğ¸ğ‘‡ğ‘ˆğ‘…ğ‘ | ğ‘…ğ¸ğ‘‡ğ‘ˆğ‘…ğ‘
Other Rules
ğ‘¡ğ‘¦ğ‘ğ‘’ â†’ ğ‘‡ğ‘Œğ‘ƒğ¸_ğ‘‰ğ‘‚ğ¼ğ· | ğ‘‡ğ‘Œğ‘ƒğ¸_ğµğ‘‚ğ‘‚ğ¿ | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¶ğ»ğ´ğ‘… | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¼ğ‘ğ‘‡ | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¹ğ¿ğ‘‚ğ´ğ‘‡
ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ â†’ ğµğ‘‚ğ‘‚ğ¿ | ğ¶ğ»ğ´ğ‘… |ğ¼ğ‘ğ‘‡ğ¸ğºğ¸ğ‘… | ğ¹ğ¿ğ‘‚ğ´ğ‘‡

             quadruplets
The following table contains a list of quads generated by EZLang.
Almost every quadruple is associated with a type. Types define the data type and size (number of
bytes) of the operands and the result of the quadruples, unless otherwise indicated.
Quads work as follows:
1. Extracts the operands (if any) from the top of the stack, depending on their type.
2. Apply the operation defined by the quadruple.
3. Inserts the result (if available) back on top of the stack.
In the following table, we denote the top (last element) of the stack as ğ‘†1 and the 2nd last element
from the stack as ğ‘†2.

         Quad Operations:
ADD_<type> ğ‘†1 â† (ğ‘†2 + ğ‘†1)
SUB_<type> ğ‘†1 â† (ğ‘†2 âˆ’ ğ‘†1)
MUL_<type> ğ‘†1 â† (ğ‘†2 âˆ— ğ‘†1)
DIV_<type> ğ‘†1 â† (ğ‘†2/ğ‘†1)
MOD_<type> ğ‘†1 â† (ğ‘†2 ğ‘€ğ‘‚ğ· ğ‘†1)
NEG_<type> ğ‘†1 â† (âˆ’ğ‘†1)
AND_<type> ğ‘†1 â† (ğ‘†2 ğ´ğ‘ğ· ğ‘†1)
OR_<type> ğ‘†1 â† (ğ‘†2 ğ‘‚ğ‘… ğ‘†1)
XOR_<type> ğ‘†1 â† (ğ‘†2 ğ‘‹ğ‘‚ğ‘… ğ‘†1)
NOT_<type> ğ‘†1 â† ğ‘ğ‘‚ğ‘‡(ğ‘†1)
SHL_<type> ğ‘†1 â† (ğ‘†2 â‰ª ğ‘†1)
SHR_<type> ğ‘†1 â† (ğ‘†2 â‰« ğ‘†1)
GT_<type> ğ‘†1 â† (ğ‘†2 > ğ‘†1), Result is boolean
10 | Page
GTE_<type> ğ‘†1 â† (ğ‘†2 â‰¥ ğ‘†1), the result is boolean.
LT_<type> ğ‘†1 â† (ğ‘†2 < ğ‘†1), the result is boolean.
LTE_<type> ğ‘†1 â† (ğ‘†2 â‰¤ ğ‘†1), the result is boolean.
EQ_<type> ğ‘†1 â† (ğ‘†2 = ğ‘†1), the result is Boolean.
NEQ_<type> ğ‘†1 â† (ğ‘†2 â‰  ğ‘†1), the result is boolean.
Quad conversion type
<type>_TO_<type> Converts ğ‘†1 from type LHS to type RHS.
stack quads
PUSH_<type> <value> Pushes <value> to the top of the stack.
POP_<type> <dst> Prints ğ‘†1 and saves to <dst>.
quadruple jump
JMP <label> Unconditional jump to the given label.
JNZ_<type> <label> Jump to the label provided
do if ğ‘†1 is not equal to zero.
JZ_<type> <label> Jump to the given label if ğ‘†1 equals zero.
Function related quadruplets
PROC <ident> Defines a new procedure.
CALL <ident> Calls an already defined procedure.
RET Return from a procedure
