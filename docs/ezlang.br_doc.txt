________________________________________________________
|                                                      | 
|		     Projeto EZLanguage		       |
|                                                      |
|		By: Gabriel Luiz                       |
|______________________________________________________|
                IntroduÃ§Ã£o:
EZL Ã© um compilador de linguagem de programaÃ§Ã£o simples semelhante Ã  linguagem C, mas com menos funcionalidades,
ainda EZL preserva as expressÃµes complexas e instruÃ§Ãµes de ramificaÃ§Ã£o da linguagem C.
No EZL, usamos o Flex (uma ferramenta de geraÃ§Ã£o de compiladores semelhante ao Lex) para gerar o analisador lexer e
usou o Bison (uma ferramenta de geraÃ§Ã£o de compilador semelhante ao Yacc) para gerar o analisador de sintaxe.
Embora o EZL seja uma miniversÃ£o da linguagem C, ele fornece tÃ©cnicas poderosas de tratamento de erros com
relatÃ³rios de mensagens de erro significativas para vÃ¡rios cenÃ¡rios de erro de sintaxe e semÃ¢ntica.
VisÃ£o geral
Nesta seÃ§Ã£o, vamos dar uma breve descriÃ§Ã£o e exemplos para a sintaxe e semÃ¢ntica
permitido pela EZL. Como dissemos, Ã© quase idÃªntico Ã  linguagem C, mas com menos recursos.

            Tipos de dados:

No EZL, oferecemos suporte aos tipos de dados bÃ¡sicos, mas, infelizmente, nÃ£o oferecemos suporte a arrays ou ponteiros.
Os tipos suportados:
â€¢ void:    SÃ³ Ã© vÃ¡lido como um tipo de retorno de funÃ§Ã£o para informar que nÃ£o hÃ¡ valor para retornar
â€¢ int:     Ã‰ um tipo de dado de valor numÃ©rico inteiro.
â€¢ char:    Ã‰ um tipo de dado de valor de caractere.
â€¢ float:   Ã‰ um tipo de dado de valor numÃ©rico real.
â€¢ char:    Ã‰ um tipo de dado de valor de caractere.
â€¢ bool:    Ã‰ um tipo de dados de valor booleano que aceita verdadeiro ou falso.


            DeclaraÃ§Ãµes VariÃ¡veis/Constantes:

Em EZL, oferecemos suporte Ã  declaraÃ§Ã£o de variÃ¡veis â€‹â€‹e constantes com escopo definido. Cada variÃ¡vel ou constante tem seu prÃ³prio
escopo e vÃ¡rias variÃ¡veis/constantes podem ser declaradas com o mesmo identificador apenas se estiverem em
escopos diferentes. Como na linguagem C, as constantes devem ser inicializadas ao serem declaradas.
por exemplo:

________________________________________________________
int x;
const float PI = 3.14;
char c = 'c';
bool flag = true;
int a = 0, b, MAX = 100;
______________________________________________________

         'If-Else Control Statements:

Oferecemos suporte Ã  instruÃ§Ã£o de controle if-else quase exatamente da mesma maneira que na linguagem C. Se a condiÃ§Ã£o if
avalia para um valor diferente de zero, entÃ£o o if-body serÃ¡ executado. Caso contrÃ¡rio, o outro corpo serÃ¡
executado se existir. If-body e else-body podem ser uma declaraÃ§Ã£o ou podem ser vÃ¡rias declaraÃ§Ãµes
fechado por um bloco.
por exemplo:

______________________________________________________
if (x) {
if (y > 0)
/* if-body */;
else if (z & 1)
/* else-if-body */;
else
/* else-body */;
}
______________________________________________________

            DeclaraÃ§Ãµes de troca

Assim como a instruÃ§Ã£o if, oferecemos suporte Ã  instruÃ§Ã£o switch quase da mesma maneira que na linguagem C. o
switch-expression deve ser de valor inteiro e a case-expression deve ser um valor inteiro constante.
AlÃ©m disso, nÃ£o sÃ£o permitidas vÃ¡rias expressÃµes de caso que avaliam o mesmo valor. Como C, o cÃ³digo do
caso correspondente serÃ¡ executado e a execuÃ§Ã£o continuarÃ¡ no cÃ³digo abaixo de outros casos atÃ© que um
a instruÃ§Ã£o break foi encontrada.

______________________________________________________

switch (state) {
case 1:
case 2:
/* do something */
case RUNNING: // RUNNING deve ser definido como constante
/* do something */
break;
default:
/* default */
}
______________________________________________________

            Loops For/While/Do-While
EZL suporta loops quase exatamente da mesma maneira que na linguagem C. Damos suporte a loops for, loops while,
e loops do-while. Break-statements e continue-statements sÃ£o suportados dentro do escopo de um
loop e funcionam como na linguagem C, interrompem ou continuam a execuÃ§Ã£o do loop mais interno.

exemplos:
______________________________________________________
for (initializationStatement; testExpression; updateStatement)
{
    // statements inside the body of loop
}
______________________________________________________
while (condition) {
  // code block to be executed
}
______________________________________________________
int main(void)
{
  float nota1=0,nota2=0,media=0;
  int resp;
  
  do
  {
    printf("Digite a primeira nota: ");
    scanf("%f",&nota1);
    printf("Digite a segunda nota: ");
    scanf("%f",&nota2);
    
    media = (nota1 + nota2)/2;
    printf("Media do aluno = %f\n",media);
    
    printf("Digite 1 para continuar ou 2 para sair\n");
    scanf("%d", &resp);
  
  }while (resp==1);
  
  return 0;
}
______________________________________________________

                FunÃ§Ãµes

EZL suporta funÃ§Ãµes, mas com funcionalidades limitadas do que a linguagem C. NÃ£o suportamos
parÃ¢metros padrÃ£o. NÃ£o oferecemos suporte Ã  prototipagem de funÃ§Ãµes nem Ã  sobrecarga de funÃ§Ãµes.
InstruÃ§Ãµes de retorno sÃ£o permitidas dentro do escopo de uma funÃ§Ã£o. E as funÃ§Ãµes sÃ³ podem ser definidas no
Ã‚mbito global.

exemplo:
______________________________________________________
int fibonacci(int number) {
return fibonacci(number - 1) + fibonacci(number - 2);
}
______________________________________________________

                ExpressÃµes
No EZL, oferecemos suporte a expressÃµes complexas semelhantes Ã s da linguagem C. Apoiamos quase todo o
conjunto de operadores suportados pela linguagem C com a mesma precedÃªncia e associatividade.

exemplo:
______________________________________________________

(((++x) = y++) = (5 * 200 - MAX) ^ (1 << id)) = (z = 3);
______________________________________________________

                ComentÃ¡rios

EZL suporta os mesmos estilos de comentÃ¡rio da linguagem C. Os comentÃ¡rios podem ser:

â€¢ ComentÃ¡rio de linha
// Este Ã© um comentÃ¡rio de linha

â€¢ Bloquear comentÃ¡rio (comentÃ¡rio de vÃ¡rias linhas)
/**
* Este Ã© um comentÃ¡rio em bloco
* que pode abranger
* vÃ¡rias linhas
*/

            [Erros detectados]:
Nesta seÃ§Ã£o, listarei alguns dos erros de sintaxe e semÃ¢ntica que o EZL pode detectar.

Erros de sintaxe
Erros relacionados ao escopo:

1. Blocos de cÃ³digo ou instruÃ§Ãµes (que nÃ£o sejam variÃ¡veis, constantes e declaraÃ§Ã£o/definiÃ§Ã£o de funÃ§Ã£o)
no Ã¢mbito global.
2. InstruÃ§Ã£o continue fora dos escopos for, while ou do-while.
3. Break-statement fora dos escopos for, while, do-while ou switch.
4. DeclaraÃ§Ã£o de retorno fora do escopo da funÃ§Ã£o.
5. Case e default fora do escopo do switch.

Outros erros de sintaxe:
1. VariÃ¡vel ou constante declarada com tipo void.
2. DeclaraÃ§Ã£o constante sem inicializaÃ§Ã£o.
3. Qualquer outra sintaxe invÃ¡lida

Erros semÃ¢nticos

Erros relacionados a identificador/expressÃ£o:
1. RedeclaraÃ§Ã£o do identificador no mesmo escopo.
2. Acesso de identificador nÃ£o declarado.
3. AtribuiÃ§Ã£o constante apÃ³s declaraÃ§Ã£o.
4. Tipos de operandos invÃ¡lidos. (ou seja, operandos do tipo void ou ponteiro para funÃ§Ã£o).
5. Operando flutuante para operador de mÃ³dulo.
6. Operando flutuante para operadores bit a bit.
7. Uso de variÃ¡vel nÃ£o inicializada.
8. Operadores de incremento e decremento com operando de valor r.

Erros relacionados Ã  instruÃ§Ã£o switch
1. Comandos switch e case com expressÃ£o nÃ£o inteira.
2. Enunciado de case com expressÃ£o nÃ£o constante.
3. VÃ¡rios rÃ³tulos default no escopo do switch.
4. MÃºltiplos rÃ³tulos case com a mesma expressÃ£o constante no escopo do switch.
5. InicializaÃ§Ã£o de variÃ¡veis â€‹â€‹cruzadas na instruÃ§Ã£o switch.

Erros relacionados Ã  funÃ§Ã£o:
1. Valor retornado na funÃ§Ã£o void.
2. Void retornado na funÃ§Ã£o de valor digitado.
3. Chamada de variÃ¡vel ou constante como uma funÃ§Ã£o.
4. Chamada de funÃ§Ã£o com mais/menos argumentos que seus parÃ¢metros.
5. Chamada de funÃ§Ã£o com tipo de argumento invÃ¡lido (ou seja, argumento do tipo void ou ponteiro para funÃ§Ã£o).
6. ParÃ¢metro da funÃ§Ã£o com valor padrÃ£o.

                [TOKENS]:
Usando o Flex para escrever a expressÃ£o regular dos tokens permitidos pela EZLang.
A tabela a seguir contÃ©m uma lista dessas expressÃµes regulares.

            DescriÃ§Ã£o do token Regex:
        [0-9]+ NÃºmero inteiro positivo
        (([0-9]*\.[0-9]+)|([0-9]+\.[0-9]*)) NÃºmero flutuante positivo
        ([eE][-+]?{INTEGER}) ExponenciaÃ§Ã£o
        ({INTEIRO}{EXP}|{FLOAT}{EXP}?) NÃºmero real positivo
        [_a-zA-Z]([_a-zA-Z]|[0-9])* Identificador
        (\'.\') Valor do caractere
        Valores booleanos "true", "false"
        "void", "bool", "char", "int", "float" Tipos de dados
        "if", "else", "switch", "case", "default",
        "para", "fazer", "enquanto", "quebrar", "continuar",
        "retorno", "const"

        [Palavras-chave reservadas]:
                "=",
            "+", "-", "*", "/", "%",
            "&", "|", "^", "~", ">>", "<<",
            ">", ">=", "<", "<=", "==", "!=",
            "&&", "||", "!",
            "++", "--",

        [Operadores semelhantes Ã  linguagem C]:

    "(", ")", "{", "}", ",", ":", ";" Outros tokens permitidos
    "//"(.)* ComentÃ¡rio de linha
    [ \t\r\n]+ EspaÃ§os em branco

       [Regras de produÃ§Ã£o]:

Usando o Bison para escrever as regras de produÃ§Ã£o que definem a sintaxe EZLang.
Usando os recursos de precedÃªncia e associatividade do Bison para resolver a seguinte ambiguidade:
1. A precedÃªncia e associatividade dos operadores matemÃ¡ticos.
2. O problema do else pendente.
A tabela a seguir contÃ©m uma lista das regras de produÃ§Ã£o usadas.
Usando a seguinte convenÃ§Ã£o de nomenclatura para os sÃ­mbolos abaixo:
â€¢ Palavras em maiÃºsculas para sÃ­mbolos terminais
â€¢ Palavras minÃºsculas para sÃ­mbolos nÃ£o terminais

        [Regra de ProduÃ§Ã£o de Sintaxe]:
            Regras principais:
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â†’ ğœ€
ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ â†’ '{' '}'
ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜ â†’ '{' ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘™ğ‘–ğ‘ ğ‘¡ '}'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğµğ‘…ğ¸ğ´ğ¾ ';' | ğ¶ğ‘‚ğ‘ğ‘‡ğ¼ğ‘ğ‘ˆğ¸ ';' | ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ ğ‘¤ğ‘–ğ‘¡ğ‘â„_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘‘ğ‘œ_ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ ';'
ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› | ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›_ğ‘ ğ‘¡ğ‘šğ‘¡ ';'
            DeclaraÃ§Ã£o de VariÃ¡veis/Constantes
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘…
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ¶ğ‘‚ğ‘ğ‘†ğ‘‡ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘…
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… '=' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ¶ğ‘‚ğ‘ğ‘†ğ‘‡ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… '=' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ '=' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡
ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ â†’ ğ‘šğ‘¢ğ‘™ğ‘¡ğ‘–_ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ ',' ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ '=' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
            Regras de ExpressÃµes
ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 | ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 | ğ‘’ğ‘¥ğ‘ğ‘Ÿ3
ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ‘‚ğ‘ƒğ‘…ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘’ğ‘¥ğ‘ğ‘Ÿ1 â†’ ğ‘‚ğ‘ƒğ‘…ğ‘¢ğ‘›ğ‘ğ‘Ÿğ‘¦ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
Note: ğ‘‚ğ‘ƒğ‘…ğ‘ğ‘–ğ‘›ğ‘ğ‘Ÿğ‘¦ is being substituted by all binary operators and ğ‘‚ğ‘ƒğ‘…ğ‘¢ğ‘›ğ‘ğ‘Ÿğ‘¦ is being substituted by all
unary operators except increment and decrement operators
ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 â†’ ğ¼ğ‘ğ¶ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ·ğ¸ğ¶ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘’ğ‘¥ğ‘ğ‘Ÿ2 â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ¼ğ‘ğ¶ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ğ·ğ¸ğ¶
ğ‘’ğ‘¥ğ‘ğ‘Ÿ3 â†’ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')'
ğ‘’ğ‘¥ğ‘ğ‘Ÿ3 â†’ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ | ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… | ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘ğ‘ğ‘™ğ‘™
            Regras de Ramos
ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦ â†’ ğ‘ ğ‘¡ğ‘šğ‘¡ | ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¼ğ¹ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘–ğ‘“_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¼ğ¹ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦ ğ¸ğ¿ğ‘†ğ¸ ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘ ğ‘¤ğ‘–ğ‘¡ğ‘â„_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘†ğ‘Šğ¼ğ‘‡ğ¶ğ» '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¶ğ´ğ‘†ğ¸ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ':' ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘ğ‘ğ‘ ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ·ğ¸ğ¹ğ´ğ‘ˆğ¿ğ‘‡ ':' ğ‘ ğ‘¡ğ‘šğ‘¡
ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘Šğ»ğ¼ğ¿ğ¸ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘‘ğ‘œ_ğ‘¤â„ğ‘–ğ‘™ğ‘’_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ·ğ‘‚ ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦ ğ‘Šğ»ğ¼ğ¿ğ¸ '(' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› ')'
ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ¹ğ‘‚ğ‘… '(' ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ ';' ğ‘“ğ‘œğ‘Ÿ_ğ‘’ğ‘¥ğ‘ğ‘Ÿ ';' ğ‘“ğ‘œğ‘Ÿ_ğ‘’ğ‘¥ğ‘ğ‘Ÿ ')' ğ‘ğ‘Ÿğ‘ğ‘›ğ‘â„_ğ‘ğ‘œğ‘‘ğ‘¦
ğ‘“ğ‘œğ‘Ÿ_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğœ€ | ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘“ğ‘œğ‘Ÿ_ğ‘’ğ‘¥ğ‘ğ‘Ÿ â†’ ğœ€ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›

            Regras de FunÃ§Ãµes
ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘› â†’ ğ‘¡ğ‘¦ğ‘ğ‘’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… '(' ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡ ')' ğ‘ ğ‘¡ğ‘šğ‘¡_ğ‘ğ‘™ğ‘œğ‘ğ‘˜
ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğœ€ | ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™
ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ â†’ ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™ | ğ‘ğ‘ğ‘Ÿğ‘ğ‘š_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘£ğ‘ğ‘Ÿ_ğ‘‘ğ‘’ğ‘ğ‘™
ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›_ğ‘ğ‘ğ‘™ğ‘™ â†’ ğ¼ğ·ğ¸ğ‘ğ‘‡ğ¼ğ¹ğ¼ğ¸ğ‘… '(' ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡ ')'
ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡ â†’ ğœ€ | ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ â†’ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ‘ğ‘Ÿğ‘”_ğ‘™ğ‘–ğ‘ ğ‘¡_ğ‘’ğ‘¥ğ‘¡ ',' ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘›
ğ‘Ÿğ‘’ğ‘¡ğ‘¢ğ‘Ÿğ‘›_ğ‘ ğ‘¡ğ‘šğ‘¡ â†’ ğ‘…ğ¸ğ‘‡ğ‘ˆğ‘…ğ‘ ğ‘’ğ‘¥ğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘–ğ‘œğ‘› | ğ‘…ğ¸ğ‘‡ğ‘ˆğ‘…ğ‘
Other Rules
ğ‘¡ğ‘¦ğ‘ğ‘’ â†’ ğ‘‡ğ‘Œğ‘ƒğ¸_ğ‘‰ğ‘‚ğ¼ğ· | ğ‘‡ğ‘Œğ‘ƒğ¸_ğµğ‘‚ğ‘‚ğ¿ | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¶ğ»ğ´ğ‘… | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¼ğ‘ğ‘‡ | ğ‘‡ğ‘Œğ‘ƒğ¸_ğ¹ğ¿ğ‘‚ğ´ğ‘‡
ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ â†’ ğµğ‘‚ğ‘‚ğ¿ | ğ¶ğ»ğ´ğ‘… |ğ¼ğ‘ğ‘‡ğ¸ğºğ¸ğ‘… | ğ¹ğ¿ğ‘‚ğ´ğ‘‡

            QuÃ¡druplos
A tabela a seguir contÃ©m uma lista dos quÃ¡druplos gerados pela EZLang.
Quase todo quÃ¡druplo estÃ¡ associado a um tipo. Os tipos definem o tipo de dados e o tamanho (nÃºmero de
bytes) dos operandos e o resultado dos quÃ¡druplos, salvo indicaÃ§Ã£o em contrÃ¡rio.
Os quÃ¡druplos funcionam da seguinte maneira:
1. Extrai os operandos (se houver) do topo da pilha, dependendo de seu tipo.
2. Aplica a operaÃ§Ã£o definida pelo quÃ¡druplo.
3. Insere o resultado (se disponÃ­vel) de volta no topo da pilha.
Na tabela a seguir, denotamos o topo (o Ãºltimo elemento) da pilha como ğ‘†1 e o 2Âº Ãºltimo elemento
da pilha como ğ‘†2.

        OperaÃ§Ãµes dos QuÃ¡druplos:
ADD_<type> ğ‘†1 â† (ğ‘†2 + ğ‘†1)
SUB_<type> ğ‘†1 â† (ğ‘†2 âˆ’ ğ‘†1)
MUL_<type> ğ‘†1 â† (ğ‘†2 âˆ— ğ‘†1)
DIV_<type> ğ‘†1 â† (ğ‘†2/ğ‘†1)
MOD_<type> ğ‘†1 â† (ğ‘†2 ğ‘€ğ‘‚ğ· ğ‘†1)
NEG_<type> ğ‘†1 â† (âˆ’ğ‘†1)
AND_<type> ğ‘†1 â† (ğ‘†2 ğ´ğ‘ğ· ğ‘†1)
OR_<type> ğ‘†1 â† (ğ‘†2 ğ‘‚ğ‘… ğ‘†1)
XOR_<type> ğ‘†1 â† (ğ‘†2 ğ‘‹ğ‘‚ğ‘… ğ‘†1)
NOT_<type> ğ‘†1 â† ğ‘ğ‘‚ğ‘‡(ğ‘†1)
SHL_<type> ğ‘†1 â† (ğ‘†2 â‰ª ğ‘†1)
SHR_<type> ğ‘†1 â† (ğ‘†2 â‰« ğ‘†1)
GT_<type> ğ‘†1 â† (ğ‘†2 > ğ‘†1), O resultado Ã© booleano
10 | PÃ¡gina
GTE_<tipo> ğ‘†1 â† (ğ‘†2 â‰¥ ğ‘†1), o resultado Ã© booleano.
LT_<tipo> ğ‘†1 â† (ğ‘†2 < ğ‘†1), o resultado Ã© booleano.
LTE_<tipo> ğ‘†1 â† (ğ‘†2 â‰¤ ğ‘†1), o resultado Ã© booleano.
EQ_<tipo> ğ‘†1 â† (ğ‘†2 = ğ‘†1), o resultado Ã© booleano.
NEQ_<tipo> ğ‘†1 â† (ğ‘†2 â‰  ğ‘†1), o resultado Ã© booleano.
Tipo de conversÃ£o quÃ¡drupla
<tipo>_TO_<tipo> Converte ğ‘†1 do tipo LHS para o tipo RHS.
Empilhar QuÃ¡druplos
PUSH_<tipo> <valor> Empurra <valor> para o topo da pilha.
POP_<tipo> <dst> Mostra ğ‘†1 e salva em <dst>.
salto quÃ¡druplo
JMP <rÃ³tulo> Salto incondicional para o rÃ³tulo fornecido.
JNZ_<tipo> <rÃ³tulo> Pule para o rÃ³tulo fornecido se ğ‘†1 nÃ£o for igual a zero.
JZ_<tipo> <rÃ³tulo> Pule para o rÃ³tulo fornecido se ğ‘†1 for igual a zero.
QuÃ¡druplos relacionados Ã  funÃ§Ã£o
PROC <ident> Define um novo procedimento.
CALL <ident> Chama um procedimento jÃ¡ definido.
RET Retorno de um procedimento

